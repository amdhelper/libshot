#!/usr/bin/env python3
# -*- coding: utf-8 -*-

# 强制 pystray 使用 appindicator 后端
import os
os.environ['PYSTRAY_BACKEND'] = 'appindicator'

import sys
import json
import signal
import threading
import asyncio
import locale
from PIL import Image, ImageDraw

import pystray
from pystray import MenuItem, Menu

from dbus_next.service import ServiceInterface, method
from dbus_next.aio import MessageBus
from dbus_next.constants import BusType, NameFlag

# 确保可以从当前目录导入模块
sys.path.append(os.path.dirname(__file__))
from core import OcrAndTtsProcessor

# --- 全局变量 & 常量 ---
APP_NAME = "Speechify"
DBUS_SERVICE_NAME = "org.speechify.Service"
DBUS_INTERFACE_NAME = "org.speechify.Interface"
DBUS_OBJECT_PATH = "/org/speechify/Main"

# --- 路径处理 ---
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
CONFIG_FILE = os.path.join(SCRIPT_DIR, "config.json")

# --- 国际化 (i18n) ---
TRANSLATIONS = {
    "en": {
        "initializing": "Initializing...",
        "ready_notification": f"{APP_NAME} is ready",
        "ready_message": "Models loaded successfully, ready to use.",
        "trigger_ocr": "Trigger Screenshot OCR",
        "tts_model": "TTS Model",
        "language": "Language",
        "help": "Shortcut Help",
        "exit": "Exit",
        "copy_f4": "Copy F4 Screenshot Command",
        "copy_f1": "Copy F1 Hover Command",
        "open_shortcuts": "Open System Shortcuts",
        "copy_startup": "Copy Autostart Command",
        "open_startup": "Open Autostart Settings",
        "tts_switched_notification": "TTS Engine Switched",
        "tts_switched_message": "Current engine: {engine}",
        "lang_switched_notification": "Language Switched",
        "lang_switched_message": "Language set to English.",
        "command_copied_notification": "Copied Successfully",
        "command_copied_message": "Command copied to clipboard.",
        "error_pyperclip_notification": "Copy Failed",
        "error_pyperclip_message": "Requires 'pyperclip' library. Please run: pip install pyperclip",
        "error_open_settings_notification": "Operation Failed",
        "error_open_settings_message": "Could not open system settings automatically. Please open them manually.",
    },
    "zh_CN": {
        "initializing": "正在初始化...",
        "ready_notification": f"{APP_NAME} 已就绪",
        "ready_message": "模型加载成功，可以开始使用了",
        "trigger_ocr": "手动触发截图OCR",
        "tts_model": "TTS 模型",
        "language": "语言",
        "help": "快捷键帮助",
        "exit": "退出",
        "copy_f4": "复制F4截图命令",
        "copy_f1": "复制F1悬停命令",
        "open_shortcuts": "打开系统快捷键设置",
        "copy_startup": "复制自启动命令",
        "open_startup": "打开自启动设置",
        "tts_switched_notification": "TTS引擎已切换",
        "tts_switched_message": "当前引擎: {engine}",
        "lang_switched_notification": "语言已切换",
        "lang_switched_message": "语言已设置为简体中文。",
        "command_copied_notification": "复制成功",
        "command_copied_message": "命令已复制到剪贴板",
        "error_pyperclip_notification": "复制失败",
        "error_pyperclip_message": "需要 'pyperclip' 库，请运行: pip install pyperclip",
        "error_open_settings_notification": "操作失败",
        "error_open_settings_message": "无法自动打开系统设置，请手动操作。",
    },
    "zh_TW": {
        "initializing": "正在初始化...",
        "ready_notification": f"{APP_NAME} 已就緒",
        "ready_message": "模型加載成功，可以開始使用了",
        "trigger_ocr": "手動觸發截圖OCR",
        "tts_model": "TTS 模型",
        "language": "語言",
        "help": "快捷鍵幫助",
        "exit": "退出",
        "copy_f4": "複製F4截圖命令",
        "copy_f1": "複製F1懸停命令",
        "open_shortcuts": "打開系統快捷鍵設定",
        "copy_startup": "複製自啟動命令",
        "open_startup": "打開自啟動設定",
        "tts_switched_notification": "TTS引擎已切換",
        "tts_switched_message": "當前引擎: {engine}",
        "lang_switched_notification": "語言已切換",
        "lang_switched_message": "語言已設定為繁體中文。",
        "command_copied_notification": "複製成功",
        "command_copied_message": "命令已複製到剪貼簿",
        "error_pyperclip_notification": "複製失敗",
        "error_pyperclip_message": "需要 'pyperclip' 庫，請運行: pip install pyperclip",
        "error_open_settings_notification": "操作失敗",
        "error_open_settings_message": "無法自動打開系統設定，請手動操作。",
    }
}
CURRENT_LANG = "en"

def get_language():
    """获取系统语言并映射到支持的语言"""
    try:
        # getlocale() is preferred over getdefaultlocale()
        lang, _ = locale.getlocale()
        if not lang: # Fallback if locale is not set
            lang = os.environ.get("LANG", "en_US.UTF-8")
    except Exception:
        lang = "en_US.UTF-8"
    
    if lang.startswith("zh_CN"):
        return "zh_CN"
    if lang.startswith("zh_TW") or lang.startswith("zh_HK"):
        return "zh_TW"
    return "en"

def _(key):
    """翻译函数"""
    return TRANSLATIONS.get(CURRENT_LANG, TRANSLATIONS["en"]).get(key, key)

# --- D-Bus 服务 ---
class SpeechifyService(ServiceInterface):
    def __init__(self, processor, icon):
        super().__init__(DBUS_INTERFACE_NAME)
        self.processor = processor
        self.icon = icon

    @method()
    def trigger_ocr(self):
        print("D-Bus: 收到 trigger_ocr 请求")
        # 在新线程中运行耗时任务，避免阻塞D-Bus事件循环
        threading.Thread(target=self.processor.run_full_process).start()

# --- 配置读写 ---
def get_full_config():
    try:
        with open(CONFIG_FILE, "r", encoding="utf-8") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        return {"tts_model": "edge", "language": get_language()}

def write_config(config):
    with open(CONFIG_FILE, "w", encoding="utf-8") as f:
        json.dump(config, f, indent=4)

# --- 菜单动作 ---
def _set_tts_engine_action(engine_name, icon, processor):
    config = get_full_config()
    if config.get("tts_model") != engine_name:
        config["tts_model"] = engine_name
        write_config(config)
        print(f"TTS 引擎已切换为: {engine_name}")
        
        if processor:
            processor.reload_tts_engine()

        if icon:
            icon.update_menu()
            icon.notify(
                _("tts_switched_notification"),
                _("tts_switched_message").format(engine=engine_name.upper())
            )

def set_engine_edge(icon, item, processor):
    _set_tts_engine_action('edge', icon, processor)

def set_engine_piper(icon, item, processor):
    _set_tts_engine_action('piper', icon, processor)

def set_language(lang_code, icon):
    """设置语言并重建菜单"""
    global CURRENT_LANG
    CURRENT_LANG = lang_code
    config = get_full_config()
    config["language"] = lang_code
    write_config(config)
    if icon:
        icon.update_menu()
        icon.notify(
            _("lang_switched_notification"),
            _("lang_switched_message")
        )

def create_image():
    image = Image.new('RGB', (64, 64), color='#2b2b2b')
    draw = ImageDraw.Draw(image)
    draw.rectangle([8, 8, 56, 56], fill='#0078d4')
    draw.text((16, 22), "OCR", fill='white')
    return image



# --- 快捷键帮助函数 ---
import subprocess
try:
    import pyperclip
    PYPERCLIP_AVAILABLE = True
except ImportError:
    PYPERCLIP_AVAILABLE = False

def copy_command_action(command_to_copy, icon):
    if not PYPERCLIP_AVAILABLE:
        if icon:
            icon.notify(_("error_pyperclip_notification"), _("error_pyperclip_message"))
        return
    pyperclip.copy(command_to_copy)
    if icon:
        icon.notify(_("command_copied_notification"), _("command_copied_message"))

def open_system_shortcuts(icon, item):
    commands = ["gnome-control-center keyboard", "systemsettings5 shortcuts", "xfce4-keyboard-settings"]
    opened = any(subprocess.run(cmd.split()).returncode == 0 for cmd in commands)
    if not opened and icon:
        icon.notify(_("error_open_settings_notification"), _("error_open_settings_message"))

def open_startup_apps(icon, item):
    commands = ["gnome-session-properties", "gnome-startup-applications", "kcmshell5 kcm_autostart"]
    opened = any(subprocess.run(cmd.split()).returncode == 0 for cmd in commands)
    if not opened and icon:
        icon.notify(_("error_open_settings_notification"), _("error_open_settings_message"))

# --- 菜单构建 ---
def build_menu(icon, loop, service, processor, on_quit):
    f4_command = f"python3 {os.path.join(SCRIPT_DIR, 'f4.py')}"
    f1_command = f"python3 {os.path.join(SCRIPT_DIR, 'f1.py')}"
    tray_command = f"bash {os.path.join(SCRIPT_DIR, 'tray.sh')}"

    return Menu(
        MenuItem(_('trigger_ocr'), lambda: service.trigger_ocr()),
        Menu.SEPARATOR,
        MenuItem(_('tts_model'), Menu(
            MenuItem('Edge TTS', lambda icon, item: set_engine_edge(icon, item, processor), checked=lambda item: get_full_config().get("tts_model") == 'edge', radio=True),
            MenuItem('Piper TTS', lambda icon, item: set_engine_piper(icon, item, processor), checked=lambda item: get_full_config().get("tts_model") == 'piper', radio=True)
        )),
        MenuItem(_('language'), Menu(
            MenuItem('English', lambda: set_language('en', icon), checked=lambda item: get_full_config().get("language") == 'en', radio=True),
            MenuItem('简体中文', lambda: set_language('zh_CN', icon), checked=lambda item: get_full_config().get("language") == 'zh_CN', radio=True),
            MenuItem('繁體中文', lambda: set_language('zh_TW', icon), checked=lambda item: get_full_config().get("language") == 'zh_TW', radio=True)
        )),
        MenuItem(_('help'), Menu(
            MenuItem(_('copy_f4'), lambda: copy_command_action(f4_command, icon)),
            MenuItem(_('copy_f1'), lambda: copy_command_action(f1_command, icon)),
            MenuItem(_('open_shortcuts'), open_system_shortcuts),
            Menu.SEPARATOR,
            MenuItem(_('copy_startup'), lambda: copy_command_action(tray_command, icon)),
            MenuItem(_('open_startup'), open_startup_apps)
        )),
        Menu.SEPARATOR,
        MenuItem(_('exit'), on_quit)
    )

# --- 主程序 ---
async def main_async(icon):
    global CURRENT_LANG
    config = get_full_config()
    CURRENT_LANG = config.get("language", get_language())

    bus = await MessageBus(bus_type=BusType.SESSION).connect()
    
    try:
        await bus.request_name(DBUS_SERVICE_NAME, NameFlag.DO_NOT_QUEUE)
    except Exception:
        print(f"错误: 服务 '{DBUS_SERVICE_NAME}' 已在运行。正在退出。")
        return

    print("D-Bus服务名获取成功，应用为唯一实例。")

    print("正在加载AI模型，请稍候...")
    processor = OcrAndTtsProcessor()
    print("模型加载完毕，服务准备就绪。")
    icon.notify(_("ready_notification"), _("ready_message"))

    service = SpeechifyService(processor, icon)
    bus.export(DBUS_OBJECT_PATH, service)
    print(f"D-Bus服务已在 '{DBUS_OBJECT_PATH}' 发布。")

    loop = asyncio.get_running_loop()
    
    # --- 优雅退出逻辑 ---
    exit_event = asyncio.Event()
    
    def on_quit():
        print("正在退出...")
        if not exit_event.is_set():
            # 从非异步线程安全地设置事件
            loop.call_soon_threadsafe(exit_event.set)

    # 在启动托盘前设置好退出函数
    icon.menu = build_menu(icon, loop, service, processor, on_quit)
    
    # 在单独的线程中运行 pystray icon
    tray_thread = threading.Thread(target=icon.run)
    tray_thread.daemon = True
    tray_thread.start()

    # 等待退出信号
    await exit_event.wait()
    
    print("主事件循环收到退出信号，开始清理...")
    
    # 清理 D-Bus 连接
    bus.disconnect()
    
    # 停止托盘图标
    icon.stop()
    
    # 清理核心处理器资源
    processor.cleanup()
    
    print("清理完成。")


async def shutdown(loop, icon):
    """优雅地取消所有正在运行的 asyncio 任务。"""
    if icon and icon.visible:
        icon.stop()

    print("正在取消所有活动的 asyncio 任务...")
    tasks = [t for t in asyncio.all_tasks(loop=loop) if t is not asyncio.current_task()]
    if tasks:
        [task.cancel() for task in tasks]
        await asyncio.gather(*tasks, return_exceptions=True)
    
    print("所有任务已取消。")

def main():
    # 设置初始语言
    global CURRENT_LANG
    CURRENT_LANG = get_full_config().get("language", get_language())

    image = create_image()
    icon = pystray.Icon(APP_NAME.lower(), image, f"{APP_NAME} 服务", menu=Menu(MenuItem(_("initializing"), None)))

    loop = asyncio.new_event_loop()
    asyncio.set_event_loop(loop)

    def signal_handler(sig, frame):
        print(f"捕获到信号 {sig}, 正在启动关闭流程...")
        # 触发 main_async 中的退出事件
        # 这是从信号处理器（主线程）与 asyncio 循环交互的安全方式
        if loop.is_running():
            # 查找 on_quit 函数并调用它
            # 这是一个简化的方法；在实际应用中，最好有一个更直接的方式来触发退出。
            # 在我们的案例中，直接停止图标会触发退出流程。
            if icon:
                icon.stop()
        else:
            sys.exit(0)

    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

    try:
        loop.run_until_complete(main_async(icon))
    except Exception as e:
        print(f"主循环中发生未捕获的异常: {e}")
    finally:
        print("开始最终的事件循环清理...")
        # 确保在退出前所有任务都被取消
        loop.run_until_complete(shutdown(loop, icon))
        loop.close()
        print("程序已干净地退出。")

if __name__ == '__main__':
    main()
